--[[
	Grids are made up of SpaceTypes (1 to N x 1 to M). 
	They have an indication of start & end given by the 
	  StartSpace and EndSpace attributes, respectively.
	
	Grids will be generated by the Generator and built from the Builder classes.
	
	The constructor takes two arguments:
		numRows - Integer - The number of rows in the grid;
		numCols - Integer - The number of columns in the grid.
		
	A Grid instance has the following methods:
		getExitDirection () : Direction
			Purpose: Calculates & Returns the direction of the exit,
			           where the direction is which side the exit is to its
					   nearest empty space.
			Arguments: None
			Returns: Direction; Indicates the position of the exit. That is:
				Left = The exit is in the previous column from the floor;
				Right = The exit is in the next column from the floor;
				Up    = The exit is in the previous row of the floor;
				Down  = The exit is in the next row from the floor;
				nil   = The exit is completely surrounded by walls.
		reset ()
			Purpose: Resets the grid, replacing all spaces with walls.
		setResettable (space : Space, canReset : Boolean)
			Purpose: Sets whether or not a space will be reset by the reset () method.
			Arguments:
				space    Space     The space to set resettable / not resettable
				canReset  Boolean  Whether or not the space can be set to a wall.
			Returns: None
		
	The following getters:
		numColumns () : Integer
		numRows () : Integer
		getStartSpace () : Space
		getEndSpace () : Space
		getSpaceType (position : Space) : SpaceType
		getSpaceTypeRC (row : Integer, col : Integer) : SpaceType
		isResettable (space : Space) : Boolean
		
	And the following setters:
		setStartSpace (s : Space)
		setEndSpace (s : Space)
		setSpaceType (position : Space, spaceType : SpaceType)
		
	Note that getEndSpace & getStartSpace will return nil if no end/start space has been set
--]]

local Grid = { };
local G    = { };

local classes = script.Parent;

-- Dependencies
local Space = require (classes.Space);
local SpaceType = require (classes.SpaceType);
local Direction = require (classes.Direction);

-- ** Constructor ** --
function G.new (numRows, numColumns)
	return setmetatable({
		_numColumns = numColumns,
		_numRows    = numRows,
		_endSpace   = Space.new (),
		_startSpace = Space.new (),
		_grid       = { },
		
		_resettable = { }
	}, Grid);
end

-- ** Public Methods ** --
-- Determines the direction the player will be moving from the exit
function Grid:getExitDirection (position)
	local exitPosition = position or self:getEndSpace ();
	
	-- Check each direction individually to find the floor
	-- Once floor is found, we can return the direction
	if (self:_isFloor (exitPosition + Direction.Up)) then
		return Direction.Down;
	elseif (self:_isFloor (exitPosition + Direction.Down)) then
		return Direction.Up;
	elseif (self:_isFloor (exitPosition + Direction.Left)) then
		return Direction.Right;
	elseif (self:_isFloor (exitPosition + Direction.Right)) then
		return Direction.Left;
	else
		return nil;
	end
end

-- Reset the Grid, returning everything to walls
function Grid:reset ()
	local start = self:getStartSpace ();
	for row = 1,self._numRows do
		for col = 1,self._numColumns do
			local space = Space.new (row, col);
			if (self:isResettable (space)) then
				self:setSpaceType (space, SpaceType.Wall);
			end
		end
	end
	self:setSpaceType (start, SpaceType.Floor);
end

-- Resettable
function Grid:setResettable (space, canReset)
	self._resettable [space] = canReset;
end

-- ** Public Getters ** --
-- Number of columns, rows in the maze
function Grid:numColumns() return self._numColumns; end
function Grid:numRows() return self._numRows; end

-- Spaces
-- Get the start, end spaces
function Grid:getStartSpace() return self._startSpace; end
function Grid:getEndSpace() return self._endSpace; end

-- SpaceType
-- Get the space type from Row, Column
function Grid:getSpaceTypeRC (row, column)
	local space = Space.new (row, column);
	return self:getSpaceType (space);
end

-- Get the space type at a given position
function Grid:getSpaceType (space)
	-- Special Cases
	if (space == self:getStartSpace()) then return SpaceType.Start; end
	if (space == self:getEndSpace()) then return SpaceType.End; end
	
	
	local colNum = space:getCol ();
	local rowNum = space:getRow ();
	
	if (not self:_withinBorder (colNum, rowNum)) then return SpaceType.None end
	
	local spaceType = self._grid [colNum] and self._grid [colNum] [rowNum];
	return spaceType or SpaceType.Default;
end

-- Resettable
function Grid:isResettable (space)
	return self._resettable [space] ~= false;
end

-- ** Public Setters ** --
-- Set the start, end spaces
function Grid:setStartSpace (space)
	self._startSpace = space;
end
function Grid:setEndSpace (space)
	self._endSpace = space;
end

-- Set the spacetype at a given position
function Grid:setSpaceType (space, spaceType)
	local colNum = space:getCol ();
	local rowNum = space:getRow ();
	
	if (not self:_withinBorder (colNum, rowNum)) then return false end
	
	if (not self._grid [colNum]) then self._grid [colNum] = { }; end
	self._grid [colNum] [rowNum] = spaceType;
end


-- ** Private Methods ** --
-- Check if position is a floor
function Grid:_isFloor (position)
	return self:getSpaceType (position) == SpaceType.Floor;
end

-- Check if a given column & row are within the borders of the grid
function Grid:_withinBorder (column, row)
	if (self:_outside (column, self._numColumns)) then return false end
	return (not self:_outside (row, self._numRows))
end

-- Check if a given value is within the range 0 < value < max
function Grid:_outside (value, maxVal)
	return (value < 1 or value > maxVal);
end

-- String type at a given index
function Grid:_posToStr (position)
	if (position == self:getEndSpace()) then
		return SpaceType.string (SpaceType.End);
	elseif (position == self:getStartSpace()) then
		return SpaceType.string (SpaceType.Start);
	end
	return SpaceType.string (self:getSpaceType (position));
end

-- ** Metamethods ** --
function Grid:__tostring ()
	local str = "";
	for row = 1, self._numRows do
		for col = 1, self._numColumns do
			str = str .. self:_posToStr (Space.new (row, col));
		end
		str = str .. "\n";
	end
	return str;
end

Grid.__index = Grid;
return G;